{"name":"Restendpoint","tagline":"Asynchronous REST client based on Apache Http Async","body":"# restendpoint [![Build Status](https://travis-ci.org/avarabyeu/restendpoint.svg?branch=master)](https://travis-ci.org/avarabyeu/restendpoint)\r\n\r\nAsynchronous REST client based on Apache Http Async Client\r\n\r\n\r\n* [Maven Dependencies](#maven-dependencies)\r\n* [Getting Started](#getting-started)\r\n   * [As Simple As It's Possible](#as-simple-as-its-possible)\r\n   * [Creating](#creating)    \r\n      * [Default and Simpliest](#default-and-simpliest)\r\n      * [Using Builder](#using-builder)\r\n      * [Build HttpAsyncClient explicitly](#build-httpasyncclient-explicitly)      \r\n   * [Sending Requests](#sending-requests)\r\n      * [GET](#get)\r\n      * [POST/PUT](#post/put)\r\n      * [POST Multipart](#post-multipart)\r\n      * [As Command](#as-command)\r\n   * [Serializers](#serializers)\r\n\r\nBasically, **restendpoint** is convenient wrapper around \r\n[Apache HttpComponents Async Client](http://hc.apache.org/httpcomponents-asyncclient-4.0.x/)\r\n\r\n## Maven Dependencies\r\n\r\nLast stable version:\r\n```xml\r\n<dependency>\r\n    <groupId>com.github.avarabyeu</groupId>\r\n    <artifactId>restendpoint</artifactId>\r\n    <version>0.0.5</version>\r\n</dependency>\r\n```\r\n\r\n## Getting Started\r\n\r\n### As Simple As It's Possible\r\n\r\n#### Interface-based RestEndpoint\r\nUsing RestEndpoint, you do not need to create implementation of you http client. No any implementation at all! \r\nOnly thing you need is to create interface with method declarations marked with appropriate annotations:\r\n\r\n```java\r\n\r\npublic interface SomeYourService {\r\n    /* just simple GET request */\r\n    @Request(method = HttpMethod.GET, url = \"/\")\r\n    String get();\r\n\r\n    /* GET request with placeholder in path */\r\n    @Request(method = HttpMethod.GET, url = \"/{path}\")\r\n    String getWithPath(@Path(\"path\") String path);\r\n\r\n    /* GET request with query parameters, e.g. ?someParameter=someValue */\r\n    @Request(method = HttpMethod.GET, url = \"/\")\r\n    String getWithQuery(@Query Map<String, String> queryParams);\r\n\r\n    /* POST request with some body */\r\n    @Request(method = HttpMethod.POST, url = \"/\")\r\n    String post(@Body String body);\r\n\r\n    /* PUT request with some body */\r\n    @Request(method = HttpMethod.PUT, url = \"/\")\r\n    String put(@Body String body);\r\n\r\n    /* DELETE request */\r\n    @Request(method = HttpMethod.DELETE, url = \"/\")\r\n    String delete();\r\n\r\n    /* Asynchronous GET request */\r\n    @Request(method = HttpMethod.GET, url = \"/\")\r\n    Will<String> getAsync();\r\n\r\n    /* Asynchronous POST request */\r\n    @Request(method = HttpMethod.POST, url = \"/\")\r\n    Will<String> postAsync(@Body String body);\r\n\r\n    /* Asynchronous PUT request */\r\n    @Request(method = HttpMethod.PUT, url = \"/\")\r\n    Will<String> putAsync(@Body String body);\r\n\r\n    /* Asynchronous DELETE request */\r\n    @Request(method = HttpMethod.DELETE, url = \"/\")\r\n    Will<String> deleteAsync();\r\n}\r\n\r\n```\r\n... and create instance of your service:\r\n\r\n```java\r\nSomeYourService service = RestEndpoints.create()\r\n        .withBaseUrl(\"http://localhost\")\r\n        .withSerializer(new StringSerializer())                \r\n        .forInterface(RestInterface.class);\r\n```\r\n\r\nThat's it! RestEndpoint reads your interface and builds implementation based on Java Proxies. No any actions is required from you, http client is done. \r\n\r\n#### Classic RestEndpoint\r\n\r\n```java\r\n/* Creates default RestEndpoint */\r\nRestEndpoint endpoint = RestEndpoints.createDefault(\"http://airports.pidgets.com/\");\r\n\r\n /* Executes GET request to\r\n  * http://airports.pidgets.com/v1/airports?country=Belarus&format=json\r\n  * asynchronously\r\n  */\r\nWill<String> airports = endpoint.get(\r\n   \"/v1/airports\",\r\n   ImmutableMap.<String, String>builder()\r\n      .put(\"country\", \"Belarus\").put(\"format\", \"json\").build(),\r\n   String.class);\r\n\r\n/* Waits for result and prints it once received */\r\nSystem.out.println(airports.obtain());\r\n```\r\n\r\n### Creating\r\n\r\n#### Default and Simpliest\r\n```java\r\nRestEndpoint endpoint = RestEndpoints.createDefault(\"http://airports.pidgets.com/\");\r\n```\r\nCreates RestEndpoint with all available serializers, default http client configuration and built-in error handler. \r\n\r\n\r\n#### Using Builder\r\n```java\r\nRestEndpoint endpoint = RestEndpoints.create()\r\n   .withBaseUrl(\"http://base_url_of_rest_service\")\r\n   .withSerializer(new GsonSerializer())\r\n   .withErrorHandler(new YourCustomErrorHandler())\r\n   .withBasicAuth(\"login\", \"password\")\r\n   .build();\r\n```   \r\nCreates RestEndpoint with only JSON serializer based on Google GSON, your custom error handler. Each request to server will contain Basic Authentication headers (preemptive authentication, see more details here: [Apache Client Authentication](http://hc.apache.org/httpcomponents-client-ga/tutorial/html/authentication.html))\r\n\r\n\r\n#### Build HttpAsyncClient explicitly\r\nSometimes you need more deep http client configuration. Here is the example:\r\n\r\n```java\r\nHttpAsyncClientBuilder httpClientBuilder = HttpAsyncClientBuilder.create();\r\nCredentialsProvider credentialsProvider = new BasicCredentialsProvider();\r\ncredentialsProvider.setCredentials(AuthScope.ANY, new UsernamePasswordCredentials(\"user\", \"password\"));\r\nhttpClientBuilder.setDefaultCredentialsProvider(credentialsProvider);\r\nhttpClientBuilder.setMaxConnTotal(20);\r\nhttpClientBuilder.setMaxConnPerRoute(5);\r\n\r\nRestEndpoint endpoint = RestEndpoints.create().withBaseUrl(HTTP_TEST_URK)\r\n   .withSerializer(new StringSerializer()).withHttpClient(httpClientBuilder.build())\r\n   .build();\r\n```\r\nSo, you are able to configure HttpClient explicitly, but in this case builder's methods like #withBasicAuth() <b>will be overwritten</b>.\r\n\r\n\r\n### Sending Requests\r\n\r\n#### GET\r\n\r\n```java\r\nWill<String> responseBody = endpoint.get(\"/\", String.class);\r\n```\r\n#### POST/PUT\r\n\r\n```java\r\nWill<String> postResponseBody = endpoint.post(\"/\", \"this is request body\", String.class);\r\nWill<String> putResponseBody = endpoint.put(\"/\", \"this is request body\", String.class);\r\n```\r\n\r\n#### POST Multipart\r\n\r\n```java\r\nMultiPartRequest multiPartRequest = new MultiPartRequest.Builder().\r\n        addBinaryPart(\"part name\", \"filename.txt\",\r\n        MediaType.OCTET_STREAM.toString(),\r\n        ByteSource.wrap(\"here is body\".getBytes())).\r\n        addSerializedPart(\"this part will be serialized using serializer\", \"part body\").\r\n        build();\r\n\r\nWill<String> post = endpoint.post(\"/\", multiPartRequest, String.class);\r\n```\r\n\r\nTake a look at the request builder. We have possibility to provide some part as is (binary part, as byte array) and also\r\nwe can add part which will be serialized using some serializer. This pretty convenient when you need to send multipart request\r\nwith JSON's, for example\r\n\r\n#### DELETE\r\n\r\n```java\r\nWill<String> deleteResponseBody = endpoint.delete(\"/\", String.class);\r\n```\r\n\r\n#### AS COMMAND\r\n\r\n```java\r\nRestCommand<String, String> command = new RestCommand<String, String>(\"/\", HttpMethod.POST, \"request body\", String.class);\r\nWill<String> to = endpoint.executeRequest(command);\r\n```\r\n\r\n### Serializers\r\n\r\nTo provide a convenient way for working with different data formats, RestEndpoint uses serializers. \r\nSerializer is basically abstraction for converting data between java data types and data transmission formats (JSON, XML, String, etc). \r\nFor example, if content type of your responses is 'application/json' you need to add GsonSerializer, based on Google Gson library (https://code.google.com/p/google-gson/)\r\n\r\n```java\r\nRestEndpoint endpoint = RestEndpoints.create()\r\n   .withBaseUrl(\"http://base_url_of_rest_service\")\r\n   .withSerializer(new GsonSerializer()).build();\r\n```\r\nRestEndpoint reads content type of incoming response and decides which serializer to use (based on response content type). It also adds correct content type to your\r\noutcoming requests depending on serializer used for body converting.\r\n\r\nFor now, RestEndpoints supports the following list of serializers:\r\n\r\n* XML (based on JAXB - JaxbSerializer) \r\n* JSON (based on Gson - GsonSerializer)\r\n* Plain String (StringSerializer)\r\n* Byte Array (ByteArraySerializer)\r\n\r\nBy the way, you can implement your own serializer (by implementing appropriate interface) and provide it to RestEndpoint. \r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}